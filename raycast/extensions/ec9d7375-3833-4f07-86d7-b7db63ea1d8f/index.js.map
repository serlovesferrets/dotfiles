{
  "version": 3,
  "sources": ["../src/index.tsx", "../src/Float.ts", "../src/calulator.ts"],
  "sourcesContent": ["import { useState } from \"react\";\nimport { List } from \"@raycast/api\";\nimport { InputType, parseInputNumber } from \"./calulator\";\n\nexport interface State {\n  inputType: string;\n  binNumber: string;\n  decNumber: string;\n  hexNumber: string;\n  binFloat: binFloat | undefined;\n}\n\nexport interface binFloat {\n  singlePrecision: singlePrecFloat;\n  doublePrecision: doublePrecFloat;\n}\n\nexport interface singlePrecFloat {\n  sign: string;\n  exponent: string;\n  mantissa: string;\n  floatingPoint: string;\n  floatDecimal: string;\n}\n\nexport interface doublePrecFloat {\n  sign: string;\n  exponent: string;\n  mantissa: string;\n  floatingPoint: string;\n  floatDecimal: string;\n}\n\nexport default function Command() {\n  const [state, setState] = useState<State>({\n    binNumber: \"\",\n    decNumber: \"\",\n    hexNumber: \"\",\n    binFloat: undefined,\n    inputType: InputType.None,\n  });\n\n  const normalListItems = [\n    <List.Item title={\"Detected Input\"} accessoryTitle={state.inputType} />,\n    <List.Item title={\"Binary Representation\"} accessoryTitle={state.binNumber} />,\n    <List.Item title={\"Decimal Representation\"} accessoryTitle={state.decNumber} />,\n    <List.Item title={\"Hexadecimal Representation\"} accessoryTitle={state.hexNumber} />,\n  ];\n\n  const commaListItems = [\n    <List.Item title={\"Detected Input\"} accessoryTitle={state.inputType} />,\n    <List.Item title={\"Fixed Point Binary Representation\"} accessoryTitle={state.binNumber} />,\n    <List.Item title={\"Fixed Point Decimal Representation\"} accessoryTitle={state.decNumber} />,\n    <List.Section title={\"Floating Point Binary Representation \u2014 Single Precision\"}>\n      <List.Item title={\"Sign\"} accessoryTitle={state.binFloat?.singlePrecision.sign} />\n      <List.Item title={\"Exponent\"} accessoryTitle={state.binFloat?.singlePrecision.exponent} />\n      <List.Item title={\"Mantissa\"} accessoryTitle={state.binFloat?.singlePrecision.mantissa} />\n      <List.Item title={\"Floating Point\"} accessoryTitle={state.binFloat?.singlePrecision.floatingPoint} />\n      <List.Item title={\"Floating Point Decimal\"} accessoryTitle={state.binFloat?.singlePrecision.floatDecimal} />\n    </List.Section>,\n    <List.Section title={\"Floating Point Binary Representation \u2014 Double Precision\"}>\n      <List.Item title={\"Sign\"} accessoryTitle={state.binFloat?.doublePrecision.sign} />\n      <List.Item title={\"Exponent\"} accessoryTitle={state.binFloat?.doublePrecision.exponent} />\n      <List.Item title={\"Mantissa\"} accessoryTitle={state.binFloat?.doublePrecision.mantissa} />\n      <List.Item title={\"Floating Point\"} accessoryTitle={state.binFloat?.doublePrecision.floatingPoint} />\n      <List.Item title={\"Floating Point Decimal\"} accessoryTitle={state.binFloat?.doublePrecision.floatDecimal} />\n    </List.Section>,\n  ];\n  const isComma = state.inputType === InputType.BinaryComma || state.inputType === InputType.DecimalComma;\n  return (\n    //if the inputType is either Binary with comma or decimal with comma, then instead of showing the different representation show the number as a fixed point binary and a floating point binary broken down into its components\n    <List\n      isLoading={!state.inputType}\n      searchBarPlaceholder=\"Enter your calculation: 0b0101+0xff...\"\n      onSearchTextChange={async (text) => {\n        parseInputNumber(text, setState);\n      }}\n    >\n      {!isComma\n        ? normalListItems.map((item) => {\n            return item;\n          })\n        : commaListItems.map((item) => {\n            return item;\n          })}\n    </List>\n  );\n}\n", "abstract class BinaryFloat {\n  sign = 0;\n  exponent = 0;\n  mantissa = \"0\";\n  fixedBinary: string;\n  floatBinary = \"\";\n  protected constructor(number: string) {\n    this.fixedBinary = number;\n    this.setSign();\n    this.setExponentAndMantissa();\n    this.setFloatBinary();\n  }\n\n  /**\n   * Returns the sign of the number\n   */\n  abstract setSign(): void;\n\n  /**\n   * Returns the exponent of the number\n   */\n  abstract setExponentAndMantissa(): void;\n\n  /**\n   * Sets the float binary of the number\n   */\n  abstract setFloatBinary(): void;\n\n  getMantissa(): string {\n    return this.mantissa;\n  }\n\n  getExponent(): number {\n    return this.exponent;\n  }\n\n  getSign(): number {\n    return this.sign;\n  }\n\n  getFloatBinary(): string {\n    return this.floatBinary;\n  }\n\n  abstract getFloatDecimal(): string;\n}\n\nexport class SinglePrecision extends BinaryFloat {\n  constructor(number: string) {\n    super(number);\n  }\n\n  setExponentAndMantissa(): void {\n    //the exponent is how many places the comma has to be moved, so that only a 1 is at the front + 127\n    //if the number is negative, the exponent is 127 - the number of places the comma has to be moved\n    const { delta, mantissa } = normalizeNumber(this.fixedBinary);\n    this.exponent = delta + 127;\n    this.mantissa = mantissa;\n  }\n\n  getMantissa(): string {\n    return this.mantissa;\n  }\n\n  setSign(): void {\n    //if the number is negative return 1\n    //if the number is positive return 0\n    console.log(this.fixedBinary[0]);\n    if (this.fixedBinary[0] === \"-\") {\n      this.sign = 1;\n    } else {\n      this.sign = 0;\n    }\n  }\n\n  setFloatBinary(): void {\n    //check if the mantissa is longer than 23 bits\n    if (this.mantissa.length > 23) {\n      //if it is, cut off the rest\n      this.mantissa = this.mantissa.slice(0, 23);\n    }\n\n    this.floatBinary =\n      this.sign.toString() +\n      \" \" +\n      this.exponent.toString(2) +\n      \"0\".repeat(8 - this.exponent.toString(2).length) +\n      \" \" +\n      this.mantissa +\n      \"0\".repeat(23 - this.mantissa.length);\n  }\n\n  getFloatDecimal(): string {\n    //convert the float binary to decimal\n    let decimal = 0;\n    for (let i = 0; i < this.mantissa.length; i++) {\n      decimal += parseInt(this.mantissa[i]) * Math.pow(2, -1 * (i + 1));\n    }\n    //add 1 to the decimal\n    decimal += 1;\n    //multiply the decimal with 2 to the power of the exponent - 127\n    decimal *= Math.pow(2, this.exponent - 127);\n    //if the sign is 1, the number is negative\n    if (this.sign === 1) {\n      decimal *= -1;\n    }\n    return decimal.toString();\n  }\n}\n\nexport class DoublePrecision extends BinaryFloat {\n  getFloatDecimal(): string {\n    //convert the mantissa to decimal\n    let mantissa = 0;\n    for (let i = 0; i < this.mantissa.length; i++) {\n      mantissa += parseInt(this.mantissa[i]) * Math.pow(2, -1 * (i + 1));\n    }\n    //add 1 to the mantissa\n    mantissa += 1;\n    //multiply the mantissa with 2 to the power of the exponent - 127\n    mantissa *= Math.pow(2, this.exponent - 1023);\n    //if the sign is 1, the number is negative\n    if (this.sign === 1) {\n      mantissa *= -1;\n    }\n    return mantissa.toString();\n  }\n  constructor(number: string) {\n    super(number);\n  }\n\n  setExponentAndMantissa(): void {\n    //the exponent is how many places the comma has to be moved, so that only a 1 is at the front + 127\n    //if the number is negative, the exponent is 127 - the number of places the comma has to be moved\n    const { delta, mantissa } = normalizeNumber(this.fixedBinary);\n    this.exponent = delta + 1023;\n    this.mantissa = mantissa;\n  }\n\n  getMantissa(): string {\n    return this.mantissa;\n  }\n\n  setSign(): void {\n    //if the number is negative return 1\n    //if the number is positive return 0\n    if (this.fixedBinary[0] === \"-\") {\n      this.sign = 1;\n    } else {\n      this.sign = 0;\n    }\n  }\n\n  setFloatBinary(): void {\n    //check if the mantissa is longer than 23 bits\n    if (this.mantissa.length > 52) {\n      //if it is, cut off the rest\n      this.mantissa = this.mantissa.slice(0, 52);\n    }\n\n    this.floatBinary =\n      this.sign.toString() +\n      \" \" +\n      this.exponent.toString(2) +\n      \"0\".repeat(11 - this.exponent.toString(2).length) +\n      \" \" +\n      this.mantissa +\n      \"0\".repeat(52 - this.mantissa.length);\n  }\n}\n\n/**\n * Returns the delta (exponent) and the mantissa of the normalized number\n * @param fixedPoint the number to normalize in the form of a fixed point binary number\n * @returns {{delta: number, mantissa: string}}\n */\nfunction normalizeNumber(fixedPoint: string) {\n  //if the number is negative, remove the minus sign\n  fixedPoint = fixedPoint.replace(\"-\", \"\");\n  //if the number is positive, remove the plus sign\n  fixedPoint = fixedPoint.replace(\"+\", \"\");\n\n  //normalize comma notation\n  fixedPoint = fixedPoint.replace(\",\", \".\");\n\n  //convert the number to an array\n  let fixedPointArray = fixedPoint.split(\"\");\n  //find the closest 1 to the comma\n  const commaIndex = fixedPointArray.indexOf(\".\");\n\n  let closestOneIndex = NaN;\n\n  const farthestOneIndex = NaN;\n\n  fixedPointArray = fixedPointArray.filter(function (letter) {\n    return letter != \",\";\n  });\n\n  console.log(fixedPointArray);\n\n  //find first 1\n  for (let i = 0; i < fixedPointArray.length; i++) {\n    if (fixedPointArray[i] === \"1\") {\n      closestOneIndex = i;\n      break;\n    }\n  }\n\n  console.log(\"closest one index: \" + closestOneIndex);\n  console.log(\"comma index: \" + commaIndex);\n  const exponent = commaIndex - closestOneIndex;\n\n  //calculate the delta\n  let mantissa: string;\n\n  console.log(exponent);\n\n  if (!isNaN(farthestOneIndex)) {\n    mantissa = fixedPointArray\n      .slice(farthestOneIndex + 1)\n      .join(\"\")\n      .replace(\",\", \"\")\n      .replace(\".\", \"\");\n  } else {\n    mantissa = fixedPointArray\n      .slice(closestOneIndex + 1)\n      .join(\"\")\n      .replace(\",\", \"\")\n      .replace(\".\", \"\");\n  }\n\n  return {\n    delta: exponent,\n    mantissa: mantissa,\n  };\n}\n", "import React from \"react\";\nimport { binFloat, doublePrecFloat, singlePrecFloat, State } from \"./index\";\nimport { DoublePrecision, SinglePrecision } from \"./Float\";\n\nfunction getSign(number: string) {\n  return number.slice(0, 1) == \"-\" ? \"-\" : \"\";\n}\n\nfunction binaryCommaParser(number: string, setState: (value: ((prevState: State) => State) | State) => void) {\n  //the input is a binary number with a comma\n  //calculate the floating point number in single precision and double precision\n  const singlePrecBinFloat = new SinglePrecision(number);\n  const doublePrecBinFloat = new DoublePrecision(number);\n\n  //convert the floating point numbers to decimal\n  const singlePrecDec = singlePrecBinFloat.getFloatDecimal();\n  const doublePrecDec = doublePrecBinFloat.getFloatDecimal();\n\n  //convert the fixed point numbers to decimal\n  const fixedPointArray = number.includes(\",\") ? number.split(\",\") : number.split(\".\");\n  const fixedPointDec =\n    number.slice(0, 1) +\n    parseInt(fixedPointArray[0], 2) +\n    parseInt(fixedPointArray[1], 2) / 2 ** fixedPointArray[1].length;\n\n  setState({\n    inputType: InputType.BinaryComma,\n    binNumber: number,\n    decNumber: fixedPointDec.toString(),\n    hexNumber: \"\",\n    binFloat: {\n      singlePrecision: {\n        sign: singlePrecBinFloat.getSign().toString(),\n        exponent: singlePrecBinFloat.getExponent().toString(),\n        mantissa: singlePrecBinFloat.getMantissa().toString(),\n        floatingPoint: singlePrecBinFloat.getFloatBinary().toString(),\n        floatDecimal: singlePrecDec.toString(),\n      } as singlePrecFloat,\n      doublePrecision: {\n        sign: doublePrecBinFloat.getSign().toString(),\n        exponent: doublePrecBinFloat.getExponent().toString(),\n        mantissa: doublePrecBinFloat.getMantissa().toString(),\n        floatingPoint: doublePrecBinFloat.getFloatBinary().toString(),\n        floatDecimal: doublePrecDec.toString(),\n      } as doublePrecFloat,\n    } as unknown as binFloat,\n  });\n}\n\nfunction decimalCommaParser(number: string, setState: (value: ((prevState: State) => State) | State) => void) {\n  //convert the decimal comma number to a fixed float binary number\n  const fixedPointArray = number.includes(\",\") ? number.split(\",\") : number.split(\".\");\n  const fixedPointBinFirstPart = parseInt(fixedPointArray[0]).toString(2);\n\n  let binaryRep = \"\";\n  const demialString = \"0.\" + fixedPointArray[1];\n  let decimalRep = parseFloat(demialString);\n\n  for (let i = 0; i < 64 && decimalRep != 0; i++) {\n    if (decimalRep >= 1) {\n      binaryRep += \"1\";\n      decimalRep--;\n    } else {\n      binaryRep += \"0\";\n    }\n    decimalRep *= 2;\n  }\n\n  const fixedPointBin = getSign(number) + fixedPointBinFirstPart + \".\" + binaryRep.slice(1);\n\n  //calculate the floating point number in single precision and double precision\n  const singlePrecBinFloat = new SinglePrecision(fixedPointBin);\n  const doublePrecBinFloat = new DoublePrecision(fixedPointBin);\n\n  setState({\n    inputType: InputType.DecimalComma,\n    binNumber: getSign(number) == \"-\" ? fixedPointBin.slice(0, 10) : fixedPointBin.slice(0, 9),\n    decNumber: number,\n    hexNumber: \"\",\n    binFloat: {\n      singlePrecision: {\n        sign: singlePrecBinFloat.getSign().toString(),\n        exponent: singlePrecBinFloat.getExponent().toString(),\n        mantissa: singlePrecBinFloat.getMantissa().toString(),\n        floatingPoint: singlePrecBinFloat.getFloatBinary().toString(),\n        floatDecimal: singlePrecBinFloat.getFloatDecimal(),\n      } as singlePrecFloat,\n      doublePrecision: {\n        sign: doublePrecBinFloat.getSign().toString(),\n        exponent: doublePrecBinFloat.getExponent().toString(),\n        mantissa: doublePrecBinFloat.getMantissa().toString(),\n        floatingPoint: doublePrecBinFloat.getFloatBinary().toString(),\n        floatDecimal: doublePrecBinFloat.getFloatDecimal(),\n      } as doublePrecFloat,\n    } as unknown as binFloat,\n  });\n}\n\nexport function parseInputNumber(number: string, setState: React.Dispatch<React.SetStateAction<State>>) {\n  number = number.replaceAll(\" \", \"\");\n  console.log(number);\n  if (\n    number\n      .replace(\"-\", \"\")\n      .slice(2)\n      .match(/^-?[0-1]+[,.][0-1]+$/) &&\n    number.replace(\"-\", \"\").slice(0, 2) == \"0b\"\n  ) {\n    console.log(\"Binary comma\");\n    binaryCommaParser(number, setState);\n  }\n  //check for decimal with comma\n  else if (number.match(/^-?[0-9]+[.,][0-9]+$/)) {\n    decimalCommaParser(number, setState);\n  } else {\n    // the input can be as long as we want and can be a mix of different types\n    // split the input into an array of numbers and operators\n    const numberArray = number.split(/([+*/%^-])/);\n\n    const convertedArray = [];\n\n    for (let i = 0; i < numberArray.length; i++) {\n      if (numberArray[i] != \"\" && !numberArray[i].match(/([+*/%^-])/)) {\n        convertedArray.push(convertToDec(numberArray[i]));\n      } else {\n        convertedArray.push(numberArray[i]);\n      }\n    }\n\n    console.log(convertedArray);\n\n    //loop through the converted array and calculate the result by using the operator on the numbers\n    let result = convertedArray[0] as { number: number; type: InputType };\n    const inputs = [result.type];\n    for (let i = 1; i < convertedArray.length; i += 2) {\n      const operator = convertedArray[i] as string;\n      const value = convertedArray[i + 1] as { number: number; type: InputType };\n      if (value.number == undefined || result.number == undefined) {\n        break;\n      }\n      inputs.push(operator as InputType);\n      switch (operator) {\n        case \"+\":\n          result.number += value.number;\n          inputs.push(value.type);\n          break;\n        case \"-\":\n          result.number -= value.number;\n          inputs.push(value.type);\n          break;\n        case \"*\":\n          result.number *= value.number;\n          inputs.push(value.type);\n          break;\n        case \"/\":\n          result.number /= value.number;\n          inputs.push(value.type);\n          break;\n        case \"%\":\n          result.number %= value.number;\n          inputs.push(value.type);\n          break;\n        case \"^\":\n          result.number **= value.number;\n          inputs.push(value.type);\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (result.number == undefined) {\n      result = { number: 0, type: InputType.None };\n    }\n\n    //convert inputs to string\n    setState({\n      inputType: inputs.toString().replaceAll(\",\", \" \") ?? \"\",\n      binNumber: result.number.toString(2),\n      decNumber: result.number.toString(),\n      hexNumber: result.number.toString(16),\n      binFloat: undefined,\n    });\n  }\n}\n\nfunction convertToDec(number: string) {\n  const radixTable: any = {\n    \"0b\": { radix: 2, type: InputType.Binary },\n    \"0x\": { radix: 16, type: InputType.Hexadecimal },\n    \"0o\": { radix: 8, type: InputType.Octal },\n  };\n  let radix = 10;\n  let inputType = InputType.Decimal;\n  if (number.slice(0, 2) in radixTable) {\n    radix = radixTable[number.slice(0, 2)].radix;\n    inputType = radixTable[number.slice(0, 2)].type;\n    number = number.slice(2);\n  }\n  return {\n    number: parseInt(number, radix),\n    type: inputType,\n  };\n}\n\nexport enum InputType {\n  None = \"\",\n  Binary = \"Binary\",\n  Decimal = \"Decimal\",\n  Hexadecimal = \"Hexadecimal\",\n  Octal = \"Octal\",\n  BinaryComma = \"Binary with comma\",\n  DecimalComma = \"Decimal with comma\",\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "Command", "__toCommonJS", "import_react", "import_api", "BinaryFloat", "number", "SinglePrecision", "delta", "mantissa", "normalizeNumber", "decimal", "DoublePrecision", "fixedPoint", "fixedPointArray", "commaIndex", "closestOneIndex", "farthestOneIndex", "letter", "i", "exponent", "getSign", "number", "binaryCommaParser", "setState", "singlePrecBinFloat", "SinglePrecision", "doublePrecBinFloat", "DoublePrecision", "singlePrecDec", "doublePrecDec", "fixedPointArray", "fixedPointDec", "decimalCommaParser", "fixedPointBinFirstPart", "binaryRep", "demialString", "decimalRep", "i", "fixedPointBin", "parseInputNumber", "numberArray", "convertedArray", "convertToDec", "result", "inputs", "operator", "value", "radixTable", "radix", "inputType", "import_jsx_runtime", "Command", "state", "setState", "normalListItems", "commaListItems", "isComma", "text", "parseInputNumber", "item"]
}
